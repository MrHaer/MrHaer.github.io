# 2021年7月25日的笔记----树状数组、线段树和状压DP
注：为了让自己不忘记所以要做笔记
今天上午学到了beautiful的两个数据结构！下午又学了一种DP！

## 1. 树状数组
<img src="2021年7月25日的笔记-1.png" alt="tu1"  />
树状数组的样子就这样，我们发现：
	1.a数组非常正常
	2.c数组按照每个元素的为2的因数的个数“连边”
它的作用就是方便求区间和。蓝书上说，它用来**维护序列的前缀和。**
一般的数组修改查询单点是O(1)的，求区间和却是O(n)的，但这个树状数组可以用O(logn)的时间复杂度查询。蓝书上说，**c[x]保存序列a的区间[x - lowbit(x) + 1, x]中所有数的和。**

代码模板：

```c++
int lowbit(int x)//求二进制下最低位的一个1，原理略
{
    return x&-x;
}//它可以直接放到下面两个函数里
void upd(int pos,int val)//在更新a数组时用来更新c数组，原理看书
{
    for(int i=pos;i<=n;i+=lowbit(i))
        c[i]=max(c[i],val);
}
int query(int pos)//就是查询一下
{
    int res=0;
    for(int i=pos;i>0;i-=lowbit(i))
        res=max(res,c[i]);
    return res;
}
//以上代码是c老师的模板
```

## 2.线段树

线段树就贼NM离谱！可拿来很快的查、改区间值。原理图：

![tu2](C:\Users\admin\Desktop\MrHaer.github.io-main\blog\t2.png)

见到了吗，线段树就是个二叉树，管它叫“线段”是因为树上有两个端点，储存了一段区间，像把线段从mid值切开一样。因为它是一个二叉树，所以他的查询、修改复杂度都是O(n)的。

他有三个函数：build()，用来建树；upd()，用来修改区间；

```c++
```



## 3.状压DP

从学习中，我们发现了，状态压缩动态规划（以下叫状压DP）是拿来用二进制来压缩状态，一般题中N<=15，且状态只有两三种的时候（就是状态很少），我们就可以用状压DP。状压DP，用二进制压缩状态，可以把巨大的数组压缩到只有2的n次方，例如，2^15=32768，空间大小可以承受。

状压DP灵活运用了位运算，下面列举几个~~常用的~~：

```c++
1<<n == power(2,n+1);
n<<1 == n*2;
n>>1 == n/2;
n&1<<n //得到n+1位的低位的数
n|1<<n //emmmmmm...
n^<<n
```

因为是DP所以我什么都讲不出来，自己看代码体会吧。

下面是C老师的“吃奶酪”的代码：

```c++
#include <bits/stdc++.h>
#define x first
#define y second
using namespace std;

int n;
double f[40000][17];
pair<double,double>a[20];
double xx,yy,inf=1e10,dis[20][20];

int main()
{
	cin >> n;
	for(int i=1;i<=n;i++)
	{
		cin >> xx >> yy;
		a[i]=make_pair(xx,yy);
	}
	for(int i=0;i<(1<<n);i++)
		for(int j=1;j<=n;j++)
			f[i][j]=inf;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			dis[i][j]=sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y));
	for(int i=1;i<=n;i++)
		f[1<<i-1][i]=sqrt(a[i].first*a[i].first+a[i].second*a[i].second);
	for(int i=0;i<(1<<n);i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i&(1<<j-1)==0) continue;
			for(int k=1;k<=n;k++)
			{
				if(i&(1<<k-1)==0) continue;
				f[i][j]=min(f[i][j],f[i^(1<<j-1)][k]+dis[j][k]);
			}
		}
	}
	double ans=inf;
	for(int i=1;i<=n;i++)
		ans=min(ans,f[(1<<n)-1][i]);
	cout << fixed << setprecision(2) << ans;
}
```

